/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, InstantiateMsg, AcceptedDenom, ExecuteMsg, Timestamp, Uint64, RewardDistributionType, CampaignCreationSettings, QueryMsg, Addr, ArrayOfValidatedAcceptedDenom, ValidatedAcceptedDenom, ArrayOfCampaign, Campaign } from "./Factory.types";
export interface FactoryReadOnlyInterface {
  contractAddress: string;
  getCampaign: ({
    connectionId,
    validatorAddr
  }: {
    connectionId: string;
    validatorAddr: string;
  }) => Promise<Campaign>;
  getAllCampaigns: () => Promise<ArrayOfCampaign>;
  getCampaignsByConnection: ({
    connectionId
  }: {
    connectionId: string;
  }) => Promise<ArrayOfCampaign>;
}
export class FactoryQueryClient implements FactoryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getCampaign = this.getCampaign.bind(this);
    this.getAllCampaigns = this.getAllCampaigns.bind(this);
    this.getCampaignsByConnection = this.getCampaignsByConnection.bind(this);
  }

  getCampaign = async ({
    connectionId,
    validatorAddr
  }: {
    connectionId: string;
    validatorAddr: string;
  }): Promise<Campaign> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_campaign: {
        connection_id: connectionId,
        validator_addr: validatorAddr
      }
    });
  };
  getAllCampaigns = async (): Promise<ArrayOfCampaign> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_campaigns: {}
    });
  };
  getCampaignsByConnection = async ({
    connectionId
  }: {
    connectionId: string;
  }): Promise<ArrayOfCampaign> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_campaigns_by_connection: {
        connection_id: connectionId
      }
    });
  };
}
export interface FactoryInterface extends FactoryReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createCampaign: ({
    connectionId,
    expiration,
    remoteStakingDenom,
    rewardDistributionType,
    targetPosition,
    validatorAddress
  }: {
    connectionId: string;
    expiration: Timestamp;
    remoteStakingDenom: string;
    rewardDistributionType: RewardDistributionType;
    targetPosition: number;
    validatorAddress: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setCampaignContractCodeId: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addAcceptedDenom: ({
    denom,
    minAcceptedFee,
    pairContract
  }: {
    denom: string;
    minAcceptedFee: Uint128;
    pairContract: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeAcceptedDenom: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setCreationFeeAddress: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class FactoryClient extends FactoryQueryClient implements FactoryInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createCampaign = this.createCampaign.bind(this);
    this.setCampaignContractCodeId = this.setCampaignContractCodeId.bind(this);
    this.addAcceptedDenom = this.addAcceptedDenom.bind(this);
    this.removeAcceptedDenom = this.removeAcceptedDenom.bind(this);
    this.setCreationFeeAddress = this.setCreationFeeAddress.bind(this);
  }

  createCampaign = async ({
    connectionId,
    expiration,
    remoteStakingDenom,
    rewardDistributionType,
    targetPosition,
    validatorAddress
  }: {
    connectionId: string;
    expiration: Timestamp;
    remoteStakingDenom: string;
    rewardDistributionType: RewardDistributionType;
    targetPosition: number;
    validatorAddress: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_campaign: {
        connection_id: connectionId,
        expiration,
        remote_staking_denom: remoteStakingDenom,
        reward_distribution_type: rewardDistributionType,
        target_position: targetPosition,
        validator_address: validatorAddress
      }
    }, fee, memo, _funds);
  };
  setCampaignContractCodeId = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_campaign_contract_code_id: {}
    }, fee, memo, _funds);
  };
  addAcceptedDenom = async ({
    denom,
    minAcceptedFee,
    pairContract
  }: {
    denom: string;
    minAcceptedFee: Uint128;
    pairContract: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_accepted_denom: {
        denom,
        min_accepted_fee: minAcceptedFee,
        pair_contract: pairContract
      }
    }, fee, memo, _funds);
  };
  removeAcceptedDenom = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_accepted_denom: {}
    }, fee, memo, _funds);
  };
  setCreationFeeAddress = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_creation_fee_address: {}
    }, fee, memo, _funds);
  };
}